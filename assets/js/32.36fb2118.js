(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{520:function(_,t,v){"use strict";v.r(t);var a=v(31),s=Object(a.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"hash碰撞的解决方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hash碰撞的解决方法"}},[_._v("#")]),_._v(" Hash碰撞的解决方法")]),_._v(" "),v("h3",{attrs:{id:"_1、开放地址法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、开放地址法"}},[_._v("#")]),_._v(" 1、开放地址法")]),_._v(" "),v("p",[_._v("开放地执法有一个公式: "),v("code",[_._v("Hi=(H(key)+di) MOD m i=1,2,…,k(k<=m-1)")]),_._v("\n其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为"),v("code",[_._v("1,2,3,…m-1")]),_._v("，称线性探测再散列。\n如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为"),v("code",[_._v("1,-1,2,-2,4,-4,9,-9,16,-16,…k*k,-k*k(k<=m/2)")]),_._v("，称二次探测再散列。\n如果di取值可能为伪随机数列。称伪随机探测再散列。")]),_._v(" "),v("h3",{attrs:{id:"_2、再哈希法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、再哈希法"}},[_._v("#")]),_._v(" 2、再哈希法")]),_._v(" "),v("p",[_._v("当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。\n比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第二位进行哈希，再冲突，第三位，直到不冲突为止。")]),_._v(" "),v("h3",{attrs:{id:"_3、链地址法-拉链法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、链地址法-拉链法"}},[_._v("#")]),_._v(" 3、链地址法（拉链法）")]),_._v(" "),v("p",[_._v("经典的HashMap使用的方法")]),_._v(" "),v("p",[_._v("优点和缺点:")]),_._v(" "),v("p",[_._v("①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；")]),_._v(" "),v("p",[_._v("②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；")]),_._v(" "),v("p",[_._v("③"),v("strong",[_._v("开放定址法为减少冲突，要求装填因子α较小")]),_._v("，故当结点规模较大时会浪费很多空间。而拉链法中可取"),v("code",[_._v("α≥1")]),_._v("，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；")]),_._v(" "),v("p",[_._v("④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。")]),_._v(" "),v("p",[_._v("而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，"),v("strong",[_._v("只能在被删结点上做删除标记，而不能真正删除结点")]),_._v("。")])])}),[],!1,null,null,null);t.default=s.exports}}]);