(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{524:function(s,e,t){"use strict";t.r(e);var a=t(31),r=Object(a.a)({},(function(){var s=this,e=s.$createElement,t=s._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"sql语句性能优化策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sql语句性能优化策略"}},[s._v("#")]),s._v(" SQL语句性能优化策略")]),s._v(" "),t("p",[s._v("1.对于查询的优化，应尽量避免全表扫描，首先应该考虑在where及order by涉及的列上建立索引。")]),s._v(" "),t("p",[s._v("2.尽量避免在where子句中对字段进行null值判断，创建表时NULL是默认值，但是大多数时候应该使用NOT NULL，或者使用一个特殊值进行替代，例如0，-1作为默认值。")]),s._v(" "),t("p",[s._v("3.尽量避免在where子句中使用!= 或 <>操作符，这会使索引失效。MySql只对以下操作符生效：<,<=,=,>,>=,BETWEEN,以及某些时候的LIKE(abc%)。")]),s._v(" "),t("p",[s._v("4.尽量避免在where子句中使用or作为连接条件，否则将会导致引擎放弃使用索引而进行全表扫描，可以使用UNION(去重)/UNION ALL 合并查询。")]),s._v(" "),t("p",[s._v("5.慎用IN 和 NOT IN,否则会导致全表扫描，对于连续的数值可以使用BETWEEN代替IN。")]),s._v(" "),t("p",[s._v("6.where子句中使用了参数也会导致全表扫描。")]),s._v(" "),t("p",[s._v("7.尽量避免在where子句中使用表达式和函数操作。")]),s._v(" "),t("p",[s._v("8.很多时候exists代替IN是一个好的选择：")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" num "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" a "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" num "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("in")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" num "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" b"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])])]),t("p",[s._v("可以替换为：")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" num "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" a "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("exists")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" b "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" num "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("num"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])])]),t("p",[s._v("9.并不是在任何情况下都要为了提高查询效率而去建立索引，因为虽然索引提高了查询的效率但同时也降低了insert 和 update的效率，因为插入和更新操作会重新建立索引，所以说是否需要创建索引和创建怎样的索引都需要慎重考虑，视情况而定。一般一个表的索引最好不要超过6个。")]),s._v(" "),t("p",[s._v("10.尽可能的避免频繁的更新索引数据列，因为索引列的顺序就是表记录的物理存储顺序，一旦该列的值改变将导致整个表记录的顺序发生调整，这将耗费很大的资源来维护索引顺序，此时的索引将成为累赘。")])])}),[],!1,null,null,null);e.default=r.exports}}]);