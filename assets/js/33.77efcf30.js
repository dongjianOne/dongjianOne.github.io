(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{521:function(a,t,r){"use strict";r.r(t);var e=r(31),v=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"overload与override区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#overload与override区别"}},[a._v("#")]),a._v(" overload与override区别")]),a._v(" "),r("p",[a._v("overload是同一个类中存在名称完全相同和参数列表(参数类型和参数个数)不同的方法")]),a._v(" "),r("p",[a._v("override表示子类方法存在与父类名称和参数列表都完全相同的方法，创建实例调用的时候，调用的实现是子类的实现，这就相当于覆盖了父类的方法，\n这就是重写或者叫覆盖。这也是Java多态性的一种体现(Java多态性：父类引用指向子类实现)。")]),a._v(" "),r("p",[a._v("重写的要求：\n1.异常：不能抛出比父类更多的异常或者抛出的异常是父类抛出异常的子异常，子类可以解决父类的一些问题，不能比父类有更多的问题。\n2.访问权限：子类的访问权限要比父类更大，不能比父类更小")]),a._v(" "),r("h1",{attrs:{id:"抽象类abstract-class和接口-interface-的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#抽象类abstract-class和接口-interface-的区别"}},[a._v("#")]),a._v(" 抽象类abstract class和接口(interface)的区别")]),a._v(" "),r("p",[a._v("抽象类：被abstract修饰符修饰的类就是抽象类")]),a._v(" "),r("p",[a._v("接口：class修饰换成interface修饰")]),a._v(" "),r("p",[a._v("抽象类不能创建实例，含有抽象方法的类必须定义为抽象类，但是抽象类中可以有非抽象方法，并一定拥有抽象方法。抽象类中的抽象方法必须在子类中实现，所以没有抽象的构造方法和抽象的静态方法，如果父类的抽象方法没有在子类中实现那么子类也必须定义为抽象类。")]),a._v(" "),r("p",[a._v("接口其实是一种特殊的抽象类，接口中的方法必须是抽象方法，接口中的方法默认是public abstract类型，变量默认是public static final类型。")]),a._v(" "),r("p",[a._v("接口的特点：")]),a._v(" "),r("ul",[r("li",[a._v("对外暴露接口")]),a._v(" "),r("li",[a._v("功能的扩展")]),a._v(" "),r("li",[a._v("接口的出现降低耦合度（耦合是类与类之间的依赖性；内聚是类完成功能的能力）")]),a._v(" "),r("li",[a._v("接口可以完成多实现，一个接口可以实现多个父接口，用逗号隔开（多态性）")])])])}),[],!1,null,null,null);t.default=v.exports}}]);