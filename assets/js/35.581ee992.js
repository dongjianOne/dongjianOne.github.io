(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{524:function(e,t,r){"use strict";r.r(t);var s=r(31),v=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"sql语句性能优化策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sql语句性能优化策略"}},[e._v("#")]),e._v(" SQL语句性能优化策略")]),e._v(" "),r("p",[e._v("1.对于查询的优化，应尽量避免全表扫描，首先应该考虑在where及order by涉及的列上建立索引。")]),e._v(" "),r("p",[e._v("2.尽量避免在where子句中对字段进行null值判断，创建表时NULL是默认值，但是大多数时候应该使用NOT NULL，或者使用一个特殊值进行替代，例如0，-1作为默认值。")]),e._v(" "),r("p",[e._v("3.尽量避免在where子句中使用!= 或 <>操作符，这会使索引失效。MySql只对一下操作符生效：<,<=,=,>,>=,BETWEEN,以及某些时候的LIKE(abc%)。")]),e._v(" "),r("p",[e._v("4.尽量避免在where子句中使用or作为连接条件，否则将会导致引擎放弃使用索引而进行全表扫描，可以使用UNION(去重)/UNION ALL 合并查询。")]),e._v(" "),r("p",[e._v("5.慎用IN 和 NOT IN,否则会导致全表扫描，对于连续的数值可以使用BETWEEN代替IN。")]),e._v(" "),r("p",[e._v("6.where子句中使用了参数也会导致全表扫描。")]),e._v(" "),r("p",[e._v("7.尽量避免在where子句中使用表达式和函数操作。")]),e._v(" "),r("p",[e._v("8.很多时候exists代替IN是一个好的选择：")]),e._v(" "),r("p",[e._v("select num from a where num in (select num from b) 可以替换为：")]),e._v(" "),r("p",[e._v("select num from a exists(select 1 from b where num = a.num)")]),e._v(" "),r("p",[e._v("9.并不是在任何情况下都要为了提高查询效率而去建立索引，因为虽然索引提高了查询的效率但同时也降低了insert 和 update的效率，因为插入和更新操作会重新建立索引，所以说是否需要创建索引和创建怎样的索引都需要慎重考虑，视情况而定。一般一个表的索引最好不要超过6个。")]),e._v(" "),r("p",[e._v("10.尽可能的避免频繁的更新索引数据列，因为索引列的顺序就是表记录的物理存储顺序，一旦该列的值改变将导致整个表记录的顺序发生调整，这将耗费很大的资源来维护索引顺序，此时的索引将成为累赘。")])])}),[],!1,null,null,null);t.default=v.exports}}]);